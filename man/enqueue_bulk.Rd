% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bulk.R
\name{enqueue_bulk}
\alias{enqueue_bulk}
\alias{enqueue_bulk_submit}
\title{Bulk queuing}
\usage{
enqueue_bulk(X, FUN, rrq, do.call = FALSE, group = NULL,
  timeout = Inf, time_poll = 1, delete_tasks = FALSE,
  progress_bar = TRUE, env = parent.frame())

enqueue_bulk_submit(X, FUN, rrq, do.call = FALSE, group = NULL,
  progress_bar = TRUE, env = parent.frame())
}
\arguments{
\item{X}{An object to loop over.  If a list, we'll loop over the
elements of the list, duplicating the behaviour of
\code{\link{rrqlapply}} except for not handling dots.  If a
\code{data.frame} we'll loop over the \emph{rows}.  Matrices are
not supported.}

\item{FUN}{A function.  Will be found in the same way as
\code{FUN} within \code{\link{rrqlapply}}.}

\item{rrq}{An rrq object}

\item{do.call}{Behave like (but not via) \code{\link{do.call}};
given an element \code{el}, rather than run \code{FUN(el)} run
\code{FUN(el[[1]], el[[2]], ...)}.}

\item{group}{Name of a group for generated task ids.  If not
included, an ID will be generated.}

\item{timeout}{Total length of time to wait for tasks to be
completed.  The default is to wait forever (like \code{lapply}).}

\item{time_poll}{Time to poll for tasks.  Must be an integer.
Because of how the function is implemented, R will be
unresponsive for this long each iteration (unless results are
returned), so the default of 1s should be reasonable.}

\item{delete_tasks}{Delete tasks on successful finish?}

\item{progress_bar}{Display a progress bar?}

\item{env}{Environment to look in}
}
\description{
Bulk queuing.  Similar in some respects to things like
\code{\link{apply}}.  This is an experiment to deal with the
pattern where you have a big pile of parameters in a data.frame to
loop over, by applying a function to each row.
}
\details{
There are two modes here; selected with \code{do.call}.  With
\code{do.call=FALSE}, the default, the function behaves similarly
to \code{apply(X, FUN, 1)}; that is the function is applied to
each row of the data.frame (as a list):
\code{FUN(as.list(X[1,]))}, \code{FUN(as.list(X[2,]))}, and so on.
The alternative mode (\code{do.call=TRUE}) is where the
\code{data.frame} contains \emph{parameters} to the function
\code{FUN} so equivalent to \code{FUN(X[1,1], X[1,2], ...}.  This
is similar (but not implemented as) running: \code{do.call("FUN",
as.list(X[1,]))}.

Be careful, this one is going to change, including the name
probably.  You have been warned.
}
